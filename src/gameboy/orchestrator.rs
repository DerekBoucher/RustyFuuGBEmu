use crate::{
    cpu::events::{Event, Trace},
    interface,
    observables::{self, Subscriber},
};

use super::Orchestrator;
use crossbeam::channel::{self, RecvTimeoutError};
use std::time::Duration;

#[path = "orchestrator_test.rs"]
#[cfg(test)]
mod test;

impl Orchestrator {
    pub fn new() -> (
        Self,
        channel::Receiver<()>,      // close_receiver used by GB thread
        channel::Sender<()>,        // ack_sender used by GB thread to join
        channel::Receiver<Vec<u8>>, // rom_data_receiver used by GB thread
        channel::Sender<
            // frame_data_sender used by GB thread to send pixel data generated by the PPU
            [[interface::Pixel; interface::NATIVE_SCREEN_WIDTH]; interface::NATIVE_SCREEN_HEIGHT],
        >,
        channel::Receiver<bool>,
        channel::Receiver<(Event, observables::Subscriber<Trace>)>,
        channel::Receiver<(Event, uuid::Uuid)>,
    ) {
        let (close_sender, close_receiver) = channel::unbounded();
        let (ack_sender, ack_receiver) = channel::unbounded();
        let (rom_data_sender, rom_data_receiver) = channel::bounded::<Vec<u8>>(1);
        let (frame_data_sender, frame_data_receiver) = channel::bounded::<
            [[interface::Pixel; interface::NATIVE_SCREEN_WIDTH]; interface::NATIVE_SCREEN_HEIGHT],
        >(1);
        let (skip_boot_rom_sender, skip_boot_rom_recv) = channel::bounded::<bool>(1);
        let (subscribe_tx, subscribe_rx) =
            channel::unbounded::<(Event, observables::Subscriber<Trace>)>();
        let (unsubscribe_tx, unsubscribe_rx) = channel::unbounded::<(Event, uuid::Uuid)>();

        (
            Self {
                close_sender,
                ack_receiver,
                rom_data_sender,
                frame_data_receiver,
                skip_boot_rom_sender,
                subscribe_tx,
                unsubscribe_tx,
            },
            close_receiver,
            ack_sender,
            rom_data_receiver,
            frame_data_sender,
            skip_boot_rom_recv,
            subscribe_rx,
            unsubscribe_rx,
        )
    }

    pub fn close(&self) {
        self.close_sender.send(()).unwrap();
    }

    pub fn join(&self) -> Result<(), RecvTimeoutError> {
        self.ack_receiver.recv_timeout(Duration::from_secs(5))
    }

    pub fn load_rom(&self, rom_data: Vec<u8>) {
        self.rom_data_sender.send(rom_data).unwrap();
    }

    pub fn set_skip_boot_rom(&self, skip_boot_rom: bool) {
        self.skip_boot_rom_sender.send(skip_boot_rom).unwrap();
    }

    pub fn render_requested(
        &self,
    ) -> Option<[[interface::Pixel; interface::NATIVE_SCREEN_WIDTH]; interface::NATIVE_SCREEN_HEIGHT]>
    {
        match self.frame_data_receiver.try_recv() {
            Ok(frame) => Some(frame),
            Err(channel::TryRecvError::Empty) => None,
            _ => None,
        }
    }

    pub fn subscribe(&self, tx: channel::Sender<Trace>, event: Event) -> uuid::Uuid {
        let sub_id = uuid::Uuid::new_v4();
        self.subscribe_tx
            .send((
                event,
                Subscriber {
                    tx,
                    id: sub_id.clone(),
                },
            ))
            .unwrap();
        return sub_id;
    }

    pub fn unsubscribe(&self, event: Event, sub_id: uuid::Uuid) {
        self.unsubscribe_tx.send((event, sub_id.clone())).unwrap();
    }
}
