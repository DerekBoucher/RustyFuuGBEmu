use crate::{cpu::events::Event, interface, observables};

use super::Orchestrator;
use crossbeam::channel::{self, RecvTimeoutError};
use std::time::Duration;

#[path = "orchestrator_test.rs"]
#[cfg(test)]
mod test;

impl Orchestrator {
    pub fn new() -> (
        Self,
        channel::Receiver<()>,      // close_receiver used by GB thread
        channel::Sender<()>,        // ack_sender used by GB thread to join
        channel::Receiver<Vec<u8>>, // rom_data_receiver used by GB thread
        channel::Sender<
            // frame_data_sender used by GB thread to send pixel data generated by the PPU
            [[interface::Pixel; interface::NATIVE_SCREEN_WIDTH]; interface::NATIVE_SCREEN_HEIGHT],
        >,
        channel::Receiver<bool>,
        channel::Receiver<(Event, observables::Subscriber<()>)>,
        channel::Receiver<(Event, uuid::Uuid)>,
    ) {
        let (close_sender, close_receiver) = channel::unbounded();
        let (ack_sender, ack_receiver) = channel::unbounded();
        let (rom_data_sender, rom_data_receiver) = channel::bounded::<Vec<u8>>(1);
        let (frame_data_sender, frame_data_receiver) = channel::bounded::<
            [[interface::Pixel; interface::NATIVE_SCREEN_WIDTH]; interface::NATIVE_SCREEN_HEIGHT],
        >(1);
        let (skip_boot_rom_sender, skip_boot_rom_recv) = channel::bounded::<bool>(1);
        let (subscribe_tx, subscribe_rx) =
            channel::unbounded::<(Event, observables::Subscriber<()>)>();
        let (unsubscribe_tx, unsubscribe_rx) = channel::unbounded::<(Event, uuid::Uuid)>();

        (
            Self {
                close_sender,
                ack_receiver,
                rom_data_sender,
                frame_data_receiver,
                skip_boot_rom_sender,
                subscribe_tx,
                unsubscribe_tx,
            },
            close_receiver,
            ack_sender,
            rom_data_receiver,
            frame_data_sender,
            skip_boot_rom_recv,
            subscribe_rx,
            unsubscribe_rx,
        )
    }

    pub fn close(&self) {
        self.close_sender.send(()).unwrap();
    }

    pub fn join(&self) -> Result<(), RecvTimeoutError> {
        self.ack_receiver.recv_timeout(Duration::from_secs(5))
    }

    pub fn load_rom(&self, rom_data: Vec<u8>) {
        self.rom_data_sender.send(rom_data).unwrap();
    }

    pub fn set_skip_boot_rom(&self, skip_boot_rom: bool) {
        self.skip_boot_rom_sender.send(skip_boot_rom).unwrap();
    }

    pub fn render_requested(
        &self,
    ) -> Option<[[interface::Pixel; interface::NATIVE_SCREEN_WIDTH]; interface::NATIVE_SCREEN_HEIGHT]>
    {
        match self.frame_data_receiver.try_recv() {
            Ok(frame) => Some(frame),
            Err(channel::TryRecvError::Empty) => None,
            _ => None,
        }
    }
}
